# Лабораторная работа №0
## Задание 
```
Сложность:
    Medium

    Соберите для своей программы 2 библиотеки - статическую и динамическую.
```

### 1. Создание статической библиотеки 
Я буду создавать библиотеку, которая будет содержать функцию вывода фразы «Hello, world!» на экран.
Создам реализацию функции в файле `libfirst.c` :

```
#include <stdio.h>

void say_hello() 
{
    printf("Hello, world!\n");
}
```
Каждую функцию библиотеки необходимо объявить в её заголовочном файле, в моем случае это `libfirst.h` :

```
void say_hello();
```
Теперь, все это дело надо скомпилировать:

```
gcc -g -c -o libfirst.o libfirst.c
```
Флаг `-с` сообщает компилятору, что необходимо пропустить этап компоновки (linking), а `-g` — сообщает о том, что отладчик — `gdb`.

После компиляции библиотеки будет создан объектный файл который необходимо упаковать в архив:


```
ar rcs libfirst.a libfirst.o
```
* r — удалять libhello.o после добавления в архив
* с — создавть новый архив, если существует — перезаписать.
* s — добавить индекс объектного файла в архив


Теперь перейдем к тесту. Создам файл `test.c` :
```
#include "libfirst.h"

int main(){
  say_hello();
  return 0;
}
```
Компилируем :

```
gcc test.c -o test -lfirst -L.
```

Ключ `-L` нужен, чтобы сообщить компилятору о месте нахождения статической библиотеки, а ключ `-l`, чтобы подключить библиотеку.

![Alt text](<Снимок экрана 2023-11-05 175501.png>)


### 2. Создание динамической библиотеки 

```
gcc -shared -fPIC -o libfirst.so hello.o
```

Когда используются статическая библиотека и динамическая библиотека, параметры компиляции GCC одинаковы: 
Чтобы создать динамическую библиотеку, введите эти команды поочередно и она запуститься с помощью файла Makefile:

```Python

gcc libfirst.c -c -fpic -o hello.o
#  компилирует файл libfirst.c в объектный файл hello.o с флагами -c (только компиляция) и -fpic (для создания позиционно-независимого кода, нужно для shared библиотек).
gcc hello.o -shared -o libhello.so
#  создает shared библиотеку libhello.so из объектного файла hello.o.
gcc test.o libhello.so -o test -L. -lhello
# компилирует test.o, линкует с libhello.so в исполняемый файл test.
./test
# запускает скомпилированную программу test для проверки.
sudo cp libhello.so ~/../../usr/bin
#  копирует shared библиотеку libhello.so в системный каталог библиотек.
./test
# запускает test еще раз, на этот раз используя библиотеку из системного каталога.
make
#  вызывает Makefile для автоматической сборки проекта.
./app
#  запускает скомпилированную программу app.
```






gcc -c -fpic hello.c -o hello.o
gcc -shared -Wl,-soname,libhello.so -o libhello.so hello.o


gcc -c -fpic hello.c -o hello.o
